<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js arap test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#stats { 
				position: absolute; 
				top: 0; 
				left: 0;
			} 
			#meshGenerationWindow {
				margin-top: 50px;
				position: absolute; 
			}
		</style>
	</head>

	<body>

		<div id="meshGenerationWindow">

			Browser puppet creation demo:<br />
			Image Segmentation + Mesh Generation + As Rigid as Possible<br />
			<br />

		    Image: <input type="file" id="imageLoader" name="imageLoader"><br /> 
		    <button type="button" id="genMeshButton">Generate Mesh</button> <br />

		    <canvas id="myCanvas" width="578" height="400"></canvas><br />

		</div>

		<script src="image-to-mesh/slic.js"></script>
		<script src="image-to-mesh/delaunay.js"></script>
		<script src="image-to-mesh/canvasutils.js"></script>
		<script src="image-to-mesh/image-to-mesh.js"></script>

		<script src="three/three.min.js"></script>
		<script src="three/stats.min.js"></script>

		<script src="arap/arap-test.js"></script>
		<script src="arap/arap.js"></script>

		<script>

			image = new Image();
			image.src = "image-to-mesh/images/testImage.jpg";
			image.onload = function() {
			    doSLICOnImage();
			}

			/*
			document.getElementById("calcContoursButton").onclick = function() {     
			    recalculateCentroids(); 
			    findEdgesOfImage();
			    recalculateContourPoints();
			};
			*/

			document.getElementById("genMeshButton").onclick = function() {  
				recalculateCentroids(); 
			    findEdgesOfImage();
			    recalculateContourPoints();

			    generateMesh();
			    redraw();

			    setupMeshAndARAP(vertices, triangles);

			    document.getElementById("meshGenerationWindow").style.display = "none";
			};

			var container;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var testMesh;

			var vertsFlatArray;
			var facesFlatArray;

			var testValueBOGO;

			stats = new Stats();
			document.body.appendChild( stats.domElement );

			init();
			animate();


			function init() {

				testValueBOGO = 400;

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = -1000;

				// scene

				scene = new THREE.Scene();

				var ambient = new THREE.AmbientLight( 0x101030 );
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, 1 );
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onMouseDown, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function testControlPoints(x, y) {
				// move that control point
				ARAP.setControlPointPosition(controlPointIndices[0], x, y);
				for(var i = 1; i < controlPointIndices.length; i++) {
					var cpi = controlPointIndices[i];
					ARAP.setControlPointPosition(cpi, vertices[cpi][0], vertices[cpi][1]);
				}

				// update ARAP deformer
				ARAP.updateMeshDeformation();

				var empty = [];
				for(var i = 0; i < vertsFlatArray.length; i++) {
					empty.push(0);
				}
				var deformedVerts = ARAP.doArrayFunction(empty, ARAP.getMeshVertexData);

				for(var i = 0; i < deformedVerts.length; i+=2) {
					var x = deformedVerts[i];
					var y = deformedVerts[i+1];
					testMesh.geometry.vertices[i/2].x = x;
					testMesh.geometry.vertices[i/2].y = y;
				}
				testMesh.geometry.dynamic = true;
				testMesh.geometry.verticesNeedUpdate = true;

				//console.log(testMesh.geometry.vertices[0].x)
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

				if(testMesh) {
					testControlPoints(mouseX, mouseY);
				}

			}

			function onMouseDown( event ) {
				
			}

			function animate() {

				requestAnimationFrame( animate );

				update();
				render();

				stats.update();

			}

			function update() {
				/* test update geometry */
				
				/*
				if(testMesh) {
					var vertUpdateIndex = 33;
					var newX = mouseX;
					var newY = mouseY;
					var newZ = 0;
					testMesh.geometry.vertices[ vertUpdateIndex ].x = newX;
					testMesh.geometry.vertices[ vertUpdateIndex ].y = newY;
					testMesh.geometry.verticesNeedUpdate = true;
				}
				*/
				
			}

			function render() {

				camera.lookAt( scene.position );                
				camera.rotation.z = 0;

				renderer.render( scene, camera );

			}

			function setupMeshAndARAP(verts, faces) {

				/* Setup ARAP on mesh */

				/* Make flat arrays to pass to ARAP.js */
				/* Eventually this should be handled inside ARAP.js
				   (ARAP.js makes the three.js geometry for you) */
			    vertsFlatArray = [];
			    for(var i = 0; i < vertices.length; i++) {
			        vertsFlatArray.push(vertices[i][0]);
			        vertsFlatArray.push(vertices[i][1]);
			    }

			    facesFlatArray = [];
			    for(var i = 0; i < faces.length; i++) {
			        facesFlatArray.push(faces[i]);
			    }

			    /* Create the three.js geometry */
				var geometry = new THREE.Geometry();

				for(var i = 0; i < vertsFlatArray.length; i+=2) {
					var x = vertsFlatArray[i];
					var y = vertsFlatArray[i+1];
					geometry.vertices.push( new THREE.Vector3( x, y, 0 ) );
				}
				for(var i = 0; i < facesFlatArray.length; i+=3) {
					var f1 = facesFlatArray[i];
					var f2 = facesFlatArray[i+1];
					var f3 = facesFlatArray[i+2];
					geometry.faces.push( new THREE.Face3( f1, f2, f3 ) );

					geometry.faceVertexUvs[0].push( [
			            new THREE.Vector2(geometry.vertices[f1].x/canvas.width,1-geometry.vertices[f1].y/canvas.height),
			            new THREE.Vector2(geometry.vertices[f2].x/canvas.width,1-geometry.vertices[f2].y/canvas.height),
			            new THREE.Vector2(geometry.vertices[f3].x/canvas.width,1-geometry.vertices[f3].y/canvas.height)
			        ]);
				}

				geometry.dynamic = true;

				var material = new THREE.MeshBasicMaterial({
				                /*color: 0xFFFFFF,
				                wireframe: true,
				                wireframeLinewidth: 1*/

				                map: THREE.ImageUtils.loadTexture("image-to-mesh/images/testImage.jpg")
				            });

				var mesh = new THREE.Mesh(geometry, material);
				scene.add(mesh);

				testMesh = mesh;

				// clear mesh data
				ARAP.resetMesh();

				// add vertices
				ARAP.doArrayFunction(vertsFlatArray, ARAP.setMeshVertexData);

				// add faces
				ARAP.doArrayFunction(facesFlatArray, ARAP.setMeshTriangleData);

				// setup mesh deformer
				ARAP.setupMeshDeformer();

				// add control point
				for(var i = 0; i < controlPointIndices.length; i++) {
					ARAP.addControlPoint(controlPointIndices[i]);
				}

			}

		</script>

	</body>
</html>
