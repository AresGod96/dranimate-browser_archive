<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js arap test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#stats { 
				position: absolute; 
				top: 0; 
				left: 0;
			} 
			#meshGenerationWindow {
				margin-top: 50px;
				position: absolute; 
				background-color: #FFFFFF;
			}
		</style>
	</head>

	<body>

		<div id="meshGenerationWindow">

		    <input type="file" id="imageLoader" name="imageLoader"/><br /> 
		    <button type="button" id="calcContoursButton">Recalc contour points and superpixel centroids</button> <br />
		    <button type="button" id="genMeshButton">Generate Mesh</button> <br />

		    <canvas id="myCanvas" width="578" height="400"></canvas><br />

		</div>

		<script src="image-to-mesh/slic.js"></script>
		<script src="image-to-mesh/delaunay.js"></script>
		<script src="image-to-mesh/canvasutils.js"></script>
		<script src="image-to-mesh/image-to-mesh.js"></script>

		<script src="three/three.min.js"></script>
		<script src="three/stats.min.js"></script>

		<script src="arap/arap-test.js"></script>
		<script src="arap/arap.js"></script>

		<script src="testmesh.js"></script>

		<script>

			image = new Image();
			image.src = "image-to-mesh/images/testImage.jpg";
			image.onload = function() {
			    doSLICOnImage();
			}

			var container;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var testMesh;

			var testValueBOGO;

			stats = new Stats();
			document.body.appendChild( stats.domElement );

			init();
			animate();


			function init() {

				testValueBOGO = 400;

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = -1000;

				// scene

				scene = new THREE.Scene();

				var ambient = new THREE.AmbientLight( 0x101030 );
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, 1 );
				scene.add( directionalLight );

				// texture

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

				var texture = new THREE.Texture();

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};

				var onError = function ( xhr ) {
				};

				/*
				var loader = new THREE.ImageLoader( manager );
				loader.load( 'UV_Grid_Sm.jpg', function ( image ) {

					texture.image = image;
					texture.needsUpdate = true;

				} );
				*/

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onMouseDown, false );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function testControlPoints(x, y) {
				// move that control point
				ARAP.setControlPointPosition(0, x, y);
				ARAP.setControlPointPosition(100, 100, 100);

				// update ARAP deformer
				ARAP.updateMeshDeformation();

				var empty = [];
				for(var i = 0; i < testMeshVertices.length; i++) {
					empty.push(0);
				}
				var deformedVerts = ARAP.doArrayFunction(empty, ARAP.getMeshVertexData);

				for(var i = 0; i < deformedVerts.length; i+=2) {
					var x = deformedVerts[i];
					var y = deformedVerts[i+1];
					testMesh.geometry.vertices[i/2].x = x;
					testMesh.geometry.vertices[i/2].y = y;
				}
				testMesh.geometry.dynamic = true;
				testMesh.geometry.verticesNeedUpdate = true;

				//console.log(testMesh.geometry.vertices[0].x)
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

				if(testMesh) {
					testControlPoints(mouseX, mouseY);
				}

			}

			function onMouseDown( event ) {
				
			}

			function animate() {

				requestAnimationFrame( animate );

				update();
				render();

				stats.update();

			}

			function update() {
				/* test update geometry */
				
				/*
				if(testMesh) {
					var vertUpdateIndex = 33;
					var newX = mouseX;
					var newY = mouseY;
					var newZ = 0;
					testMesh.geometry.vertices[ vertUpdateIndex ].x = newX;
					testMesh.geometry.vertices[ vertUpdateIndex ].y = newY;
					testMesh.geometry.verticesNeedUpdate = true;
				}
				*/
				
			}

			function render() {

				camera.lookAt( scene.position );                
				camera.rotation.z = 0;

				renderer.render( scene, camera );

			}

			function setupMeshAndARAP() {

				/* Setup ARAP on mesh */

				// model

				var geometry = new THREE.Geometry();

				for(var i = 0; i < testMeshVertices.length; i+=2) {
					var x = testMeshVertices[i];
					var y = testMeshVertices[i+1];
					geometry.vertices.push( new THREE.Vector3( x, y, 0 ) );
				}
				for(var i = 0; i < testMeshFaces.length; i+=3) {
					var f1 = testMeshFaces[i];
					var f2 = testMeshFaces[i+1];
					var f3 = testMeshFaces[i+2];
					geometry.faces.push( new THREE.Face3( f1, f2, f3 ) );
				}

				geometry.dynamic = true;

				var material = new THREE.MeshBasicMaterial({
				                color: 0xFFFFFF,
				                wireframe: true,
				                wireframeLinewidth: 1
				            });

				var mesh = new THREE.Mesh(geometry, material);
				scene.add(mesh);

				testMesh = mesh;

				// clear mesh data
				ARAP.resetMesh();

				// add vertices
				ARAP.doArrayFunction(testMeshVertices, ARAP.setMeshVertexData);

				// add faces
				ARAP.doArrayFunction(testMeshFaces, ARAP.setMeshTriangleData);

				// setup mesh deformer
				ARAP.setupMeshDeformer();

				// add control point
				ARAP.addControlPoint(0);
				ARAP.addControlPoint(100);

				testControlPoints(0, 0);
				testControlPoints(100, 0);
				testControlPoints(200, 0);
				testControlPoints(300, 0);
				testControlPoints(400, 0);

			}

		</script>

	</body>
</html>
